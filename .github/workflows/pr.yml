name: Pull Request CI

on:
  pull_request:
    
jobs:
  find_modified_refs:
    runs-on: ubuntu-latest
    outputs:
      references: ${{ steps.find_modified_refs.outputs.references }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      - run: npm ci
      - uses: actions/github-script@v7
        id: find_modified_refs
        with:
          script: |   
            const files = await github.paginate(github.rest.pulls.listFiles, {
                owner: context.issue.owner,
                repo: context.issue.repo,
                pull_number: context.issue.number,
              },
              (response) => response.data.map((file) => file.filename.split("/"))
            );
            const fs = require('node:fs/promises');
            const yaml = require('js-yaml');
            let references = new Set();
            for (filepath of files) {
              if (filepath.length < 4){
                core.debug(`ignore file path too short : ${filepath}`)
                continue
              }
              if (filepath[0] !== "recipes") {
                core.debug(`ignore file path not in recipes : ${filepath}`)
                continue
              }
              [, package, folder] = filepath
              const fileContent = await fs.readFile(`recipes/${package}/config.yml`, 'utf8');
              const config = yaml.load(fileContent);
              core.debug(`file: ${filepath}`)
              const path = filepath.join("/") 
              if(path == `recipes/${package}/${folder}/conandata.yml`)
              {
                core.debug("conandata detected")
                const newconandata = yaml.load(await fs.readFile(path, 'utf8'))
                const response = await fetch(`${{ github.server_url }}/${{ github.event.pull_request.base.repo.owner.login }}/${{ github.event.pull_request.base.repo.name }}/raw/refs/heads/${{ github.event.pull_request.base.ref }}/${path}`)
                if(response.ok) {
                  core.debug("got old conandata successfully")
                  const oldconandata = yaml.load(await response.text())
                  for(const [version, info] of Object.entries(newconandata.sources)) 
                    if(!(version in oldconandata.sources) || JSON.stringify(info) != JSON.stringify(oldconandata.sources[version]))
                      references.add(JSON.stringify({package,version,folder}))
                  const newPatches = newconandata.patches || {};
                  const oldPatches = oldconandata.patches || {};
                  for(const [version, info] of Object.entries(newPatches)) 
                    if(!(version in oldPatches) || JSON.stringify(info) != JSON.stringify(oldPatches[version]))
                      references.add(JSON.stringify({package,version,folder}))
                  continue
                } else {
                  core.error(`error getting old conandata: ${response.status} ${response.statusText} ${response.body}`)
                }
              }
              for (const [version, info] of Object.entries(config.versions))
                if(info.folder == folder)
                  references.add(JSON.stringify({package,version,folder}))
            }
            core.setOutput('references', Array.from(references).map(JSON.parse));

  build_refs:
    needs: find_modified_refs
    if: ${{ needs.find_modified_refs.outputs.references != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.find_modified_refs.outputs.references) }}
    uses: ./.github/workflows/build_single_ref.yml
    with:
      package: ${{ matrix.package }}
      version: ${{ matrix.version }}
      folder: ${{ matrix.folder }}
      upload: false
    secrets: inherit
